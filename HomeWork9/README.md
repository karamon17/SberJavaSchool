# Домашнее задание №9 Функциональные интерфейсы – Lambda. Stream API

## Задание

Реализовать класс похожий на [java.util.stream.Stream](http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html)

**Использование этого класса должно выглядеть примерно так:**
```
List<Person> someCollection = ...

Map m = Streams.of(someCollection)
                                      .filter(p -> p.getAge() > 20)
                                      .transform( p -> new Person(p.geAge() + 30)))
                                      .toMap(p -> p.geName(), p -> p);
```

* Streams.of() - статический метод, который принимает коллекцию и создает новый объект Streams
* filter() - оставляет в коллекции только те элементы, которые удовлетворяют условию в лямбде.
* transform() - преобразует элемент в другой.
* toMap - принимает 2 лямбды для создания мапы, в одной указывается, что использовать в качестве ключа, в другой, что в качестве значения.
* После выполнения всех операций коллекция someCollection не должна поменяться.
* Класс надо параметризовать используя правило PECS


```
public class Streams<T> {
   public static Streams of(List list) {
            ....
    }

public Streams filter(........) {
           ...
         return this;
    }

public Streams transform(........) {
           ...
         return this;
    }

public Map toMap(........) {
           ...  
    }
}
```

## Теория

Функциональные интерфейсы, лямбда-выражения и Stream API - это основные концепции, введенные в Java 8, чтобы сделать работу с функциональным программированием и обработкой коллекций более удобной и выразительной.

### Функциональные интерфейсы и лямбда-выражения:

1. **Функциональные интерфейсы:**
    - Функциональный интерфейс - это интерфейс с единственным абстрактным методом (SAM - Single Abstract Method).
    - Пример: `Runnable`, `Callable`, `Comparator` и т.д.

2. **Лямбда-выражения:**
    - Лямбда-выражение - это компактный способ представления анонимных функций. Оно предоставляет короткую и более удобную альтернативу анонимным классам.
    - Пример:
      ```java
      (a, b) -> a + b
      ```

### Stream API:

1. **Введение в Stream API:**
    - `Stream` - это новый абстрактный слой, предназначенный для обработки и выполнения операций над коллекциями.
    - `Stream` не изменяет исходную коллекцию, а предоставляет результаты в виде нового `Stream`.

2. **Основные операции Stream API:**
    - **Промежуточные операции:**
        - `filter`: фильтрация элементов по заданному условию.
        - `map`: преобразование каждого элемента в другой объект.
        - `sorted`: сортировка элементов.
        - `distinct`: удаление дубликатов.

    - **Терминальные операции:**
        - `collect`: преобразование элементов в коллекцию или другую форму.
        - `forEach`: выполнение действия для каждого элемента.
        - `reduce`: выполнение агрегации элементов (например, суммирование).

3. **Пример использования Stream API:**
    ```java
    List<String> words = Arrays.asList("Java", "is", "fun", "and", "powerful");

    long count = words.stream()
                     .filter(word -> word.length() > 2)
                     .map(String::toUpperCase)
                     .count();

    System.out.println(count); // Вывод: 4
    ```

4. **Параллельные потоки:**
    - Stream API также предоставляет возможность работы с параллельными потоками, что может повысить производительность при обработке больших объемов данных.

Эти концепции позволяют писать более лаконичный, читаемый и функциональный код, улучшая структуру программы и уменьшая необходимость в многочисленных циклах и временных переменных.

## Решение

В рамках выполнения задания "Реализовать класс похожий на java.util.stream.Stream" я создал класс `Streams`, предоставляющий удобный интерфейс для манипуляций с коллекциями. Начав с метода `of`, который принимает коллекцию и создает новый объект `Streams`, я реализовал следующие операции:

1. **filter:** Метод `filter` принимает предикат и оставляет в коллекции только те элементы, которые удовлетворяют условию в лямбда-выражении.

2. **transform:** Метод `transform` принимает функцию преобразования и применяет её ко всем элементам коллекции, обновляя их.

3. **toMap:** Метод `toMap` принимает две функции для создания ключей и значений и возвращает новую `Map`, используя указанные функции для элементов коллекции.

Все эти методы возвращают объект `Streams`, что позволяет создавать цепочки операций для удобного и последовательного применения различных преобразований к коллекциям. Важно отметить, что при выполнении всех операций исходная коллекция `someCollection` не изменяется.

В ходе выполнения задания я параметризовал класс Streams с использованием правила PECS (Producer Extends, Consumer Super). Это означает, что параметры, которые будут использоваться только для чтения (получения данных), объявлены с использованием ключевого слова extends, а параметры, которые будут использоваться для записи (помещения данных), объявлены с использованием ключевого слова super.

Применение правила PECS улучшает гибкость и безопасность использования класса, так как он позволяет взаимодействовать с различными подтипами, делая код более универсальным и предотвращая потенциальные ошибки типизации.

Приведенный пример использования в методе `main` иллюстрирует работу с классом `Streams`, где фильтрация, трансформация и создание `Map` выполняются в одной цепочке операций.

Таким образом, созданный класс `Streams` обеспечивает удобный и читаемый интерфейс для работы с коллекциями, позволяя выполнять различные манипуляции с данными в функциональном стиле, аналогично `Stream API` в стандартной библиотеке Java.


# Домашнее задание №8 Сериализация – Serialization

## Задача - Кеширующий прокси

Некоторые методы могут выполняться очень долго, хочется иметь возможность кешировать результаты возврата. Иногда хочется чтобы результаты расчета могли сохраняться при перезапуске JVM.
Например, у нас есть интерфейс Service c методом doHardWork(). Повторный вызов этого метода с теми же параметрами должен возвращать рассчитанный результат из кэша.

    void run(Service service) {
        double r1 = service.doHardWork("work1", 10); //считает результат
        double r2 = service.doHardWork("work2", 5);  //считает результат
        double r3 = service.doHardWork("work1", 10); //результат из кеша
    }

### Должна быть возможность тонкой настройки кеша:
1) Указывать с помощью аннотаций, какие методы кешировать и как: Просчитанный результат хранить в памяти JVM или сериализовывать в файле на диск.
2) Возможность указывать, какие аргументы метода учитывать при определении уникальности результата, а какие игнорировать(по умолчанию все аргументы учитываются). Например, должна быть возможность указать, что doHardWork() должен игнорировать значение второго аргумента, уникальность определяется только по String аргументу.<br>
double r1 = service.doHardWork("work1", 10); //считает результат<br>
double r2 = service.doHardWork("work1", 5);  // результат из кеша, несмотря на то что  второй аргумент различается

3) Если возвращаемый тип это List – возможность указывать максимальное количество элементов в нем. То есть, если нам возвращается List с size = 1млн, мы можем сказать что в кеше достаточно хранить 100т элементов.
4) Возможность указывать название файла/ключа по которому будем храниться значение. Если не задано - использовать имя метода.
5) Если мы сохраняем результат на диск, должна быть возможность указать, что данный файл надо дополнительно сжимать в zip архив.  
6) Любые полезные настройки на ваш вкус.
7) Все настройки кеша должны быть optional и иметь дефолтные настройки.
8) Все возможные исключения должны быть обработаны с понятным описание, что делать, чтобы избежать ошибок. (Например, если вы пытаетесь сохранить на диск результат метода, но данный результат не сериализуем, надо кинуть исключение с понятным описанием как это исправить)
9) Логика по кешированию должна навешиваться с помощью DynamicProxy. Должен быть класс CacheProxy с методом cache(), который принимает ссылку на сервис и возвращает кешированную версию этого сервиса.  CacheProxy должен тоже принимать в конструкторе некоторые настройки, например рутовую папку в которой хранить файлы, дефолтные настройки кеша и тд.

**Дизайн аннотаций, атрибутов  аннотаций, классов реализаций остается на ваш вкус. Код должен быть читаем, классы не перегружены логикой, классы должны лежать в нужных пакетах.**

Пример включения кеширования (можно менять названия классов, методов, аннотаций и атрибутов):

    CacheProxy cacheProxy = new CacheProxy(...);
    Service service = cacheProxy.cache(new ServiceImpl());
    Loader loader = cacheProxy.cache(new LoaderImpl());

    interface Service {
        @Cache(cacheType = FILE, fileNamePrefix = "data", zip = true, identityBy = {String.class, double.class})
        List<String> run(String item, double value, Date date);
        @Cache(cacheType = IN_MEMORY, listList = 100_000)
        List<String> work(String item);
    }

## Решения и пояснения
**Сериализация в Java** - это процесс преобразования объекта в последовательность байтов, которую можно сохранить, передать по сети или восстановить обратно в объект. Основной целью сериализации является сохранение состояния объекта таким образом, чтобы оно могло быть восстановлено позже. Это полезно, например, при передаче объектов между различными частями программы, сохранении и загрузке данных, или передаче данных по сети.

В Java сериализация реализуется интерфейсом `Serializable`. Класс, который вы хотите сделать сериализуемым, должен реализовать этот интерфейс. После этого вы можете использовать классы `ObjectOutputStream` для записи объекта в поток байтов (сериализация) и `ObjectInputStream` для восстановления объекта из потока байтов (десериализация).

Пример сериализации может выглядеть примерно так:

```java
import java.io.*;

public class SerializationExample {
    public static void main(String[] args) {
        // Создаем объект для сериализации
        MyClass myObject = new MyClass("Hello, Serialization!");

        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("serializedObject.dat"))) {
            // Сериализуем объект
            oos.writeObject(myObject);
            System.out.println("Object serialized successfully.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// Пример класса, реализующего интерфейс Serializable
class MyClass implements Serializable {
    private String message;

    public MyClass(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }
}
```

В этом примере `MyClass` реализует `Serializable`, и объект этого класса затем сериализуется и записывается в файл "serializedObject.dat".

## Задача - Кеширующий прокси
Для решения задачи "Кеширующий прокси" был создан механизм динамического проксирования методов сервиса с использованием аннотаций. В результате выполнения домашнего задания были реализованы следующие ключевые компоненты:

1. **Аннотация `@Cache`:**
    - Аннотация, помечающая методы, подлежащие кешированию.
    - Определены атрибуты для указания типа кеша (в памяти или на диске), префикса файла, использования сжатия в zip, параметров для определения уникальности результата, и размера кеша в памяти.

2. **Enum `CacheType`:**
    - Перечисление, определяющее типы кеша: в памяти (`IN_MEMORY`) и на диске (`FILE`).

3. **Класс `CacheProxy`:**
    - Отвечает за создание прокси-объекта для указанного сервиса.
    - Использует `DynamicProxy` для создания объекта, который обрабатывает вызовы методов и применяет кеширование согласно аннотациям.

4. **Класс `CacheInvocationHandler`:**
    - Обработчик вызовов методов для прокси-объекта.
    - Проверяет наличие аннотации `@Cache`, генерирует ключ для кеша, и в случае наличия сохраненного значения возвращает его.
    - В противном случае вызывает оригинальный метод, сохраняет результат в кеше и применяет дополнительные настройки кеша.

5. **Интерфейс `Service` и класс `ServiceImpl`:**
    - Интерфейс сервиса с методами, помеченными аннотацией `@Cache`.
    - Реализация интерфейса с простыми методами.

6. **Класс `Main`:**
    - Демонстрирует использование прокси и вызов методов сервиса с поддержкой кеширования.

Решение задачи предоставляет возможность тонкой настройки кеша с использованием аннотаций, определения уникальности результатов, управления размером кеша в памяти, а также сохранения результатов на диск с опциональным сжатием в zip-архив.

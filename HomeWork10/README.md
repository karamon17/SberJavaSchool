# Домашнее задание №10 Многопоточная работа в Java – MultiThreading (1 часть)

## Задание
Дан файл содержащий несколько случайных натуральных чисел от 1 до 50. Необходимо написать многопоточное приложение,  которое параллельно рассчитает и выведет в консоль факториал для каждого числа из файла.

## Теория. Часть 1
### Многопоточная работа в Java

#### Создание потока:

В Java существует два способа создания потока:

1. **Наследование от класса `Thread`:**
   ```java
   class MyThread extends Thread {
       public void run() {
           // Код, который будет выполняться в новом потоке
       }
   }

   // Создание и запуск потока
   MyThread myThread = new MyThread();
   myThread.start();
   ```

2. **Реализация интерфейса `Runnable`:**
   ```java
   class MyRunnable implements Runnable {
       public void run() {
           // Код, который будет выполняться в новом потоке
       }
   }

   // Создание и запуск потока
   Thread myThread = new Thread(new MyRunnable());
   myThread.start();
   ```

#### Поток Daemon:

- **Daemon-потоки** - это потоки, которые выполняются в фоновом режиме и завершаются, когда завершается последний не-Daemon-поток.

   ```java
   Thread daemonThread = new Thread(() -> {
       while (true) {
           // Бесконечный цикл для выполнения задачи в фоне
       }
   });
   daemonThread.setDaemon(true); // Устанавливаем поток как Daemon
   daemonThread.start();
   ```
Стоит обратить внимание, что если в думон потоке прописан блок finally, то нет гарантий, что он будет выполнен.
Блок finally полезен для выполнения завершающих действий, таких как закрытие ресурсов, освобождение памяти и т. д.

Таким образом, при использовании демон-потоков следует быть осторожным при полагании на выполнение кода в блоке finally, поскольку он может быть пропущен в случае преждевременного завершения программы.

#### Методы `wait()`, `notify()`, `notifyAll()`:

- **`wait()`:** Метод вызывается на объекте и заставляет поток ожидать, пока другой поток не вызовет `notify()` или `notifyAll()` для того же объекта.
- **`notify()`:** Метод будит один из потоков, ожидающих на объекте, вызвавшем `wait()`.
- **`notifyAll()`:** Метод будит все потоки, ожидающие на объекте, вызвавшем `wait()`.

   ```java
   synchronized (sharedObject) {
       while (conditionIsTrue) {
           sharedObject.wait(); // Ожидание
       }

       // Выполнение задачи

       sharedObject.notify(); // Будим один поток
       // или
       sharedObject.notifyAll(); // Будим все потоки
   }
   ```

#### Метод `join()`:

- **`join()`:** Позволяет одному потоку ожидать завершения другого потока.

   ```java
   Thread thread1 = new Thread(() -> {
       // Код для выполнения в потоке 1
   });

   Thread thread2 = new Thread(() -> {
       // Код для выполнения в потоке 2
   });

   thread1.start();
   thread2.start();

   try {
       thread1.join(); // Ожидание завершения потока 1
       thread2.join(); // Ожидание завершения потока 2
   } catch (InterruptedException e) {
       e.printStackTrace();
   }
   ```

#### Приоритет потоков:

- **Приоритет потоков** от 1 до 10, где 1 - самый низкий, 10 - самый высокий. Приоритет по умолчанию - 5.

   ```java
   Thread thread = new Thread(() -> {
       // Код выполнения
   });

   thread.setPriority(Thread.MAX_PRIORITY); // Установка максимального приоритета
   thread.setPriority(Thread.MIN_PRIORITY); // Установка минимального приоритета
   ```

## Решение
Я создал интерфейс ParsingFile, а также класс FactorialCalculation для реализации логики расчета факториала в отдельных потоках, используя BigInteger для представления больших чисел.

Интерфейс ParsingFile предоставляет методы для чтения содержимого файла и преобразования строк в массив чисел. Класс ParsingFileImpl реализует этот интерфейс, предоставляя функционал для работы с файлом.

Класс FactorialCalculation реализует интерфейс Runnable, предоставляя логику для расчета факториала заданного числа в отдельном потоке, при этом используется BigInteger для обработки больших чисел, гарантируя точность результатов.

В основном классе Main используются созданные классы для чтения файла, преобразования строк в числа и создания отдельных потоков для расчета факториалов.

**Результаты работы программы:**
```
Thread 8 started
Thread 7 started
Thread 1 started
Thread 2 started
Thread 3 started
Thread 6 started
Thread 5 started
Thread 4 started
Факториал числа 3: 6
Факториал числа 14: 87178291200
Факториал числа 10: 3628800
Факториал числа 2: 2
Факториал числа 44: 2658271574788448768043625811014615890319638528000000000
Факториал числа 5: 120
Факториал числа 25: 15511210043330985984000000
Факториал числа 8: 40320
```
Отсюда видно, что потоки действительно работают паралельно, так как порядок вывода сообщений о запуске потоков и результатов их работы различен.

Соответственно, если запустить программу еще раз, то вывод будет уже другой:
```
Thread 1 started
Thread 2 started
Thread 6 started
Thread 5 started
Thread 3 started
Thread 4 started
Thread 7 started
Thread 8 started
Факториал числа 14: 87178291200
Факториал числа 10: 3628800
Факториал числа 5: 120
Факториал числа 3: 6
Факториал числа 8: 40320
Факториал числа 2: 2
Факториал числа 25: 15511210043330985984000000
Факториал числа 44: 2658271574788448768043625811014615890319638528000000000
```
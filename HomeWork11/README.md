# Домашнее задание №11 Многопоточная работа в Java – MultiThreading (2 часть)

## Ответить на вопросы:
1. Как получить ссылку на текущий поток ?
2. Зачем нужно ключевое слово synchronized ? На что его можно вещать(поле, метод, класс, конструктор..) ?
3. Захват какого монитора происходит при входе в synchronized метод/статик метод/блок ?
4. Зачем нужно ключевое слово volatile ? На что его можно вещать(поле, метод, класс, конструктор..) ?
5. Что делает метод Object#wait, Object#notify, Object#notifyAll
6. Что за исключение IllegalMonitorStateException ?
7. Что делает метод Thread#join ?
8. Что делает метод Thread#interrupt ?

## Задание
реализовать ThreadPool

    public interface ThreadPool {
    void start(); // запускает потоки. Потоки бездействуют, до тех пор пока не появится новое задание в очереди (см. execute)
    
        void execute(Runnable runnable); // складывает это задание в очередь. Освободившийся поток должен выполнить это задание. Каждое задание должны быть выполнено ровно 1 раз
    }

Сделать 2 реализации ThreadPool
1) FixedThreadPool - Количество потоков задается в конструкторе и не меняется.
2) ScalableThreadPool в конструкторе задается минимальное и максимальное(int min, int max) число потоков,
   количество запущенных потоков может быть увеличено от минимального к максимальному, если при добавлении нового задания в очередь нет свободного потока для исполнения этого задания. При отсутствии задания в очереди, количество потоков опять должно быть уменьшено до значения min

## Теория. Часть 2

### Многопоточная работа в Java

**Гонка данных (Data Race):**

- **Определение:** Гонка данных — это ситуация, когда два или более потока пытаются одновременно изменить общий ресурс (переменную), приводя к непредсказуемым результатам из-за неопределенного порядка выполнения операций.

- **Пример:**
  ```java
  int sharedVariable = 0;

  // Поток 1
  sharedVariable = sharedVariable + 1;

  // Поток 2
  sharedVariable = sharedVariable * 2;
  ```

- **Последствия гонки данных:**
   1. **Недетерминированные результаты:** Результаты операций могут зависеть от порядка выполнения потоков.
   2. **Непредсказуемое поведение программы:** Программа может давать различные результаты при каждом запуске.

- **Предотвращение гонок данных:**
   1. **Синхронизация:** Использование механизмов синхронизации, таких как `synchronized` блоки или `java.util.concurrent` классы, для обеспечения атомарности операций.
   2. **Использование `volatile`:** Ключевое слово `volatile` может гарантировать атомарность операций чтения и записи к переменной.
   3. **Использование `java.util.concurrent.atomic`:** Пакет `java.util.concurrent.atomic` предоставляет атомарные переменные для избегания гонок данных.
   4. **Использование `Lock`:** Интерфейс `Lock` предоставляет более гибкий механизм синхронизации по сравнению с `synchronized`.

**Дедлок (Deadlock):**
- **Определение:** Дедлок — это ситуация, когда два или более потока блокируются навсегда, ожидая друг друга, чтобы освободить ресурсы.

- **Пример:**
  Поток A удерживает ресурс X и ожидает ресурс Y, в то время как поток B удерживает ресурс Y и ожидает ресурс X. Оба потока будут ждать вечно.

- **Предотвращение дедлоков:**
   1. **Избегайте вложенных блокировок:** Пытайтесь минимизировать использование вложенных блокировок, чтобы уменьшить вероятность возникновения дедлока.
   2. **Устанавливайте порядок блокировки:** Убедитесь, что все потоки блокируют ресурсы в одном и том же порядке.
   3. **Используйте таймауты:** Предоставьте время ожидания при блокировке, чтобы избежать вечного ожидания.
   4. **Используйте `tryLock()`:** Метод `tryLock()` из интерфейса `Lock` позволяет попытаться захватить блокировку с таймаутом.
   5. **Используйте `Lock` вместо `synchronized`:** `Lock` из пакета `java.util.concurrent` обеспечивает больше гибкости и возможностей для предотвращения дедлоков.

**Ключевые слова `synchronized` и `volatile`:**

**`synchronized`:**
- **Определение:** `synchronized` в Java используется для обеспечения синхронизации доступа к блокам кода или методам между потоками. Когда поток входит в блок `synchronized`, он получает монитор объекта, и никакие другие потоки не могут войти в другие синхронизированные блоки этого объекта.

- **Использование:**
  ```java
  synchronized (lockObject) {
      // Блок кода требующий синхронизации
  }
  ```

**`volatile`:**
- **Определение:** Один поток не обязан видеть изменения переменных сделанные в других потоках, потому что потоки могут кэшировать значения общих переменных и работать со ссвоей версией. Чтобы такого избежать есть Volatile. При использовании Volatile переменной, все потоки будут видеть актуальные изменения сделанные в этой переменной.

- **Использование:**
  ```java
  private volatile boolean flag = false;
  ```

**Голод потоков (Thread Starvation):**

- **Определение:** Голод потоков — это ситуация, при которой определенный поток систематически лишается ресурсов (например, CPU) в пользу других потоков.

- **Причины:**
   1. **Отсутствие приоритетов:** Если потокам не назначены приоритеты, некоторые из них могут быть недостаточно уделяемыми внимания, что приводит к голоду.
   2. **Неправильная синхронизация:** Неправильное использование синхронизации может привести к блокировке одного потока и голоду других.

- **Предотвращение голода:**
   1. **Используйте приоритеты:** Назначение приоритетов потокам может помочь предотвратить голод.
   2. **Правильная синхронизация:** Обеспечивайте правильную синхронизацию и избегайте долгих блокировок.

## Ответы на вопросы:

1. Как получить ссылку на текущий поток ?
   - Ссылку на текущий поток можно получить с помощью метода `Thread.currentThread()`.
2. Зачем нужно ключевое слово synchronized ? На что его можно вешать(поле, метод, класс, конструктор..) ?
   - Ключевое слово `synchronized` используется для обеспечения синхронизации доступа к блокам кода или методам между потоками. Его можно вешать на методы и блоки кода.
3. Захват какого монитора происходит при входе в synchronized метод/статик метод/блок ?
   - При входе в `synchronized` метод или статический метод захватывается монитор объекта класса, а при входе в `synchronized` блок захватывается монитор объекта, указанного в блоке.
4. Зачем нужно ключевое слово volatile ? На что его можно вешать(поле, метод, класс, конструктор..) ?
    - Ключевое слово `volatile` используется для обеспечения видимости изменений переменных между потоками. Его можно вешать на поля.
5. Что делает метод Object#wait, Object#notify, Object#notifyAll ?
    - **`wait()`:** Метод вызывается на объекте и заставляет поток ожидать, пока другой поток не вызовет `notify()` или `notifyAll()` для того же объекта.
    - **`notify()`:** Метод будит один из потоков, ожидающих на объекте, вызвавшем `wait()`.
    - **`notifyAll()`:** Метод будит все потоки, ожидающие на объекте, вызвавшем `wait()`.
6. Что за исключение IllegalMonitorStateException ?
    - `IllegalMonitorStateException` возникает, когда поток пытается вызвать методы `wait()`, `notify()` или `notifyAll()` без захвата монитора объекта.
7. Что делает метод Thread#join ?
    - Метод `join()` позволяет одному потоку ожидать завершения другого потока.
8. Что делает метод Thread#interrupt ?
    - Метод `interrupt()` используется для прерывания потока. При вызове метода `interrupt()` у потока устанавливается флаг прерывания, который может быть проверен с помощью метода `isInterrupted()`.

## Реализация ThreadPool

Я создал два класса для реализации пулов потоков в рамках домашнего задания. Первый из них - `FixedThreadPool`, представляет собой фиксированный пул потоков с заранее заданным числом потоков. Второй - `ScalableThreadPool`, обеспечивает более гибкую настройку количества потоков в пределах минимального и максимального значения. Оба класса реализуют интерфейс `ThreadPool`, который определяет методы для запуска потоков и добавления задач в очередь.

Внутри каждого пула я использовал внутренний класс `WorkerThread`, который представляет собой поток, выполняющий задачи из очереди. Для управления потоками и предотвращения вечного ожидания, я воспользовался механизмами прерывания потоков и добавлением фиктивных задач в очередь при остановке пула. Это позволяет корректно завершить выполнение потоков.

Наконец, в Main классах, я предоставил пример использования соответствующего пула потоков. В этом примере создаются задачи, добавляются в очередь пула, и затем происходит имитация выполнения задач с использованием метода `sleep`. По завершении работы пулы останавливаются, прерывая все свои потоки.
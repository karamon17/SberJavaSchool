# Домашнее задание №5 Рефлексия, проксирование и аннотации


## Ответить на вопросы:
1) Почему на любом объекте можем вызвать метод getClass()?
2) Почему на любом классе можем вызвать .class?
3) В чём отличие динамического прокси от статического?
Приведите преимущества и недостатки.

## Задача 1
Имплементировать следующий интерфейс в классе CalculatorImpl

    public interface Calculator{
        /**
        * Расчет факториала числа.
        * @param number
        */
        int calc (int number);
    }

## Задача 2
Вывести на консоль все методы класса, включая все родительские методы
(включая приватные)

## Задача 3
Вывести все геттеры класса

## Задача 4
Проверить что все String константы имеют значение = их имени
    
    public static final String MONDAY = "MONDAY";

## Задача 5
Реализовать кэширующий прокси

## Задача 6
Создать свою аннотацию Metric. Реализовать proxy класс PerformanceProxy, который в случае если метод аннотирован Metric будет выводить на консоль время выполнения метода.
т.е. написав

    public interface Calculator{
        /**
        * Расчет факториала числа.
        * @param number
        */
        @Metric
        int calc (int number);
    }
И использовав его

    Calculator  calculator=new PerformanceProxy(new Calculator()));
    System.out.println(calculator.calc(3));
Должны увидеть:

    Время работы метода: ххххх (в наносек)
    6
## Задача 7
Реализовать следующий класс по документации

    public class BeanUtils {
        /**
        * Scans object "from" for all getters. If object "to"
          * contains correspondent setter, it will invoke it
          * to set property value for "to" which equals to the property
          * of "from".
        * <p/>
          * The type in setter should be compatible to the value returned
          * by getter (if not, no invocation performed).
          * Compatible means that parameter type in setter should
          * be the same or be superclass of the return type of the getter.
        * <p/>
          * The method takes care only about public methods.
          *
          * @param to   Object which properties will be set.
          * @param from Object which properties will be used to get values.
          */
          public static void assign(Object to, Object from) {... }
    }
## Решения и пояснения
**Java Reflection** — это особенный функционал, который позволяет программе получить доступ к приватным частям объектов или поменять поведение некоторых методов классов. Созданный таким образом код будет адаптироваться к входным данным и, например, не будет зависеть от типов, с которыми работает.

Это дает возможность писать код, который со временем будет эволюционировать, то есть не зависеть от текущих имплементаций методов или переменных. Главные преимущества рефлексии — свобода и адаптивность. При необходимости вызвать приватный метод класса можно не переписывать его, а вызвать через Java Reflection. Фактически рефлексия позволяет не следовать написанному коду, вводя новые правила. Можно пойти чуть дальше и начать перехватывать вызовы методов, подменяя их другой логикой, или создать программу, которая будет работать с еще не написанным классом.

**Прокси** — это шаблон проектирования. Мы создаем и используем его для добавления и изменения функционала уже существующих классов. В таком случае, прокси-объект применяется вместо исходного. Обычно он использует тот же метод, что и оригинальный, и в Java прокси-классы расширяют исходные.

Таким образом, прокси-классы удобно реализуют многие вещи:
- логирование старта и остановки метода;
- дополнительную проверку аргументов;
- имитацию поведения исходного класса;
- реализацию отложенной инициализации затратных ресурсов;

**Аннотации в Java** – это специальный механизм со своим синтаксисом, позволяющий добавлять в код метаданные. Какую-то дополнительную информацию, которую затем можно прочитать из исходного кода, class-файлов или получить в рантайме, то есть во время работы программы. Сами по себе аннотации на код никак не влияют, в этом смысле они подобны комментариям. Все действия происходят в коде, который ищет аннотации и на их основе меняет поведение.

## Ответы на вопросы:
1) Почему на любом объекте можем вызвать метод getClass()?

**Ответ:**

В Java все объекты наследуются от класса Object. Класс Object определяет несколько базовых методов, которые доступны для всех объектов, включая метод getClass(). Метод getClass() возвращает объект типа Class, который представляет собой метаинформацию о классе объекта.

Таким образом, возможность вызывать метод getClass() на любом объекте проистекает из того, что все объекты наследуют этот метод от класса Object. Этот метод полезен, например, когда вам нужно узнать тип объекта во время выполнения программы (runtime).

2) Почему на любом классе можем вызвать .class?

**Ответ:**

В Java, оператор `.class` используется для получения объекта типа `Class`, представляющего собой метаинформацию о классе. Этот оператор является статическим и может быть применен ко всем классам.

Например, если у вас есть класс `MyClass`, то `.class` можно использовать следующим образом:

```java
Class<?> myClass = MyClass.class;
```

Это полезно, например, при работе с рефлексией (reflection), где можно получить информацию о классе во время выполнения программы.

Таким образом, возможность использования `.class` на любом классе обусловлена языковой особенностью Java, которая предоставляет доступ к метаинформации о типах во время выполнения.

3) В чём отличие динамического прокси от статического?
   Приведите преимущества и недостатки.

**Ответ:**

#### Динамические прокси (Dynamic Proxies):
- **Генерация во время выполнения (Runtime Generation):** Динамические прокси создаются и генерируются во время выполнения программы. Они основаны на интерфейсах и работают с ними.
- **Используют `java.lang.reflect.Proxy`:** Для создания динамических прокси в Java используется класс `java.lang.reflect.Proxy` и интерфейсы, которые прокси должны реализовать.
- **Удобны для делегирования (Delegation):** Динамические прокси часто используются для создания объектов, которые делегируют свои методы другому объекту (делегату). Они предоставляют простой механизм для добавления поведения до, после или вместо вызова метода.
- **Гибкие, но могут быть медленными:** Динамические прокси предоставляют большую гибкость, но могут быть менее эффективными по сравнению со статическими прокси в определенных случаях.

#### Статические прокси (Static Proxies):
- **Генерация во время компиляции (Compile-time Generation):** Статические прокси создаются во время компиляции. Они представляют собой классы, которые реализуют интерфейс или наследуются от класса.
- **Требуют явного создания класса:** При использовании статических прокси вы должны явным образом создать новый класс, который реализует интерфейс или наследуется от класса.
- **Прозрачны и эффективны:** Статические прокси могут быть более прозрачными и эффективными, так как они создаются во время компиляции и могут быть оптимизированы компилятором.
- **Менее гибкие:** Статические прокси могут быть менее гибкими в сравнении с динамическими, так как они требуют явного создания нового класса.

#### Преимущества и недостатки:

**Динамические прокси:**
- *Преимущества:* Гибкость, возможность динамически изменять поведение объекта.
- *Недостатки:* Могут быть медленнее в определенных сценариях.

**Статические прокси:**
- *Преимущества:* Прозрачность, эффективность, более ранняя проверка на этапе компиляции.
- *Недостатки:* Менее гибкие, требуют явного создания класса.

## Задача 1
Класс CalculatorImpl имплементировал интерфейс Calculator. С помощью рекурсии реализовал метод Calc, который считает и возвращает факториал полученного числа.
## Задача 2
Создал класс Child, который наследует Parent. В обоих классах создал public и private методы. В классе Main создал метод printMethods, который с помощью рефлексии и метода getDeclaredMethods выполняет поставленную задачу. Метод вызывается рекурсивно для всех его родительских классов: printMethods(clazz.getSuperclass())
## Задача 3
Здесь аналогично присутствуют Child и Parent. Добавил в Child поля    private String name;
public int age; и соответствующие геттеры. В Main реализовал метод printGetters и метод isGetter. Решение подобно предыдущему заданию, за исключением того, что добавлен метод isGetter, который проверяет имеющийся метод, является он геттером или нет, и только если да, то выводим его на экран.
## Задача 4
Создал класс Task4, в котором присутствуют поля public static final String. Далее в классе Main с помощью рефлексии и метода getDeclaredFields получаем все поля класса Task4 и проверяем соответствуют ли они требованиям задачи. 
## Задача 5
Кэширующий прокси — это прокси-объект, который предназначен для кэширования результатов выполнения операций, чтобы избежать повторных вычислений при однотипных запросах. Это используется для оптимизации производительности, особенно в ситуациях, когда операции могут быть ресурсоемкими и повторяются с одними и теми же аргументами.

В данной задаче я создал такой кэширующий прокси.
1) CachingProxy класс:

- target: Это целевой объект, для которого будет создан прокси.
- cache: Здесь хранятся кэшированные результаты методов. Ключами являются имена методов и их аргументы.
2) createProxy метод:

- Object target: Целевой объект, для которого нужно создать прокси.
- Class<T> interfaceClass: Интерфейс, который прокси будет реализовывать.
Этот метод создает экземпляр прокси, используя Proxy.newProxyInstance. Он принимает загрузчик классов, массив интерфейсов и экземпляр CachingProxy в качестве обработчика вызовов для прокси.

3) invoke метод (из интерфейса InvocationHandler):

- Этот метод вызывается при каждом вызове метода на прокси.
- proxy: Прокси-объект, для которого вызывается метод.
- method: Метод, который вызывается.
- args: Аргументы метода.

Внутри метода создается уникальный ключ key, основанный на имени вызываемого метода и его первом аргументе. Затем проверяется, есть ли результат в кэше. Если есть, то результат возвращается из кэша; в противном случае вызывается метод на целевом объекте (method.invoke(target, args)), результат сохраняется в кэше и возвращается.
## Задача 6
1) PerformanceProxy: Это класс, реализующий интерфейс InvocationHandler, который является частью Java Reflection API. Он используется для создания динамического прокси объекта.

2) createProxy: Это статический метод, который создает прокси-объект для заданного интерфейса. Он использует Proxy.newProxyInstance, чтобы создать новый экземпляр прокси с указанным обработчиком (в данном случае, PerformanceProxy).

3) invoke: Это метод, который вызывается при вызове любого метода на прокси-объекте. Он измеряет время выполнения метода с использованием System.nanoTime() и выводит его, если метод помечен аннотацией @Metric
## Задача 7

**BeanUtils:** Этот класс предоставляет метод assign, который копирует значения свойств из объекта "from" в объект "to". Он работает на основе геттеров и сеттеров, используя рефлексию.

**Методы в BeanUtils:**

- assign: Основной метод, который копирует значения свойств из объекта "from" в объект "to". Он использует рефлексию для обнаружения геттеров в объекте "from" и соответствующих сеттеров в объекте "to". Значения свойств копируются, если типы совместимы.

- isGetter: Проверяет, является ли метод геттером. Геттер может начинаться с "get" или "is" (в случае булевых свойств) и не иметь параметров.

- getPropertyName: Извлекает имя свойства из имени геттера.

- findSetter: Ищет сеттер для заданного свойства в классе. Сеттер имеет имя "set" + имя свойства, и возвращаемый тип должен совпадать с типом свойства.

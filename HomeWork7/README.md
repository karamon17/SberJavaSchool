# Домашнее задание №7 Загрузчик классов – ClassLoaders

## Задача 1
Ваша задача написать загрузчик плагинов в вашу систему. Допустим вы пишите свою игру и хотите
чтобы люди имели имели возможность писать плагины для неё. Соответственно, разные
разработчики могут назвать свои классы одинаковым именем, ваш загрузчик должен корректно
это обрабатывать.

Задача реализовать следующий класс.
    
    package ru.sbt;

    public class PluginManager {
        private final String pluginRootDirectory;
    
        public PluginManager(String pluginRootDirectory) {
            this.pluginRootDirectory = pluginRootDirectory;
        }
    
        public Plugin load(String pluginName, String pluginClassName) {
            //todo
        }
    }

Plugin - это базовый интерфейс для всех плагинов

    public interface Plugin {
        //methods doesn't matter
        void doUsefull();
    }

PluginManager ищет скомпилированные классы плагина в папке pluginRootDirectory\pluginName\

Усложненная версия задания. Система должна вести себя корректно если в плагине, есть скомпилированные классы с именем, которые есть в вашем браузере(не в плагинах), должны использоваться классы плагина, а не вашего браузера. Для этого придется поменять модель делегирования класслоадера в методе loadClass.

## Задача 2
#### Написать EncryptedClassloader
Данный класслоадер умеет загружать классы из файлов дешифрую их. Ваша задача переопределить метод findClass(). В нем лоадер считывает зашифрованный массив байт, дешифрует его и превращает в класс (с помощью метода defineClass).

На вход класслодер принимает ключ шифрования, рутовую папку, в которой будет искать классы, родительский класслодер. Логика шифрования/дешифрования с использованием ключа может быть любой на ваш вкус (например, каждый считаный байт класса увеличить на определение число).

    public class EncryptedClassLoader extends ClassLoader {
        private final String key;
        private final File dir;
    
        public EncryptedClassLoader(String key, File dir, ClassLoader parent) {
            super(parent);
            this.key = key;
            this.dir = dir;
        }
    }

## Задача 3
Написать игру камень-ножницы-бумага, где в роли игроков будут выступать плагины (файлы с расширением jar).
Будет папка с плагинами, куда будет смотреть приложение.
Каждый плагин должен иметь своё название (по названию файла или по внутреннему состоянию кода).

Плагины будут загружаться по очереди и три раза играть в камень-ножницы-бумагa.
Плагин-победитель остаётся в памяти, а проигравший выгружается.
На место проигравшего загружается следующий плагин из папки и снова происходит игра.
Данные действия повторяются, пока мы не определим плагин-победитель (его название «имя» будет написано в кансоли). Также по сообщениям из консоли мы должны осозновать, что происходит в процессе отбора победителя.
Предположительно плагин-игрок должен содержать в себе реализацию интерфейса, пример:

    Interface PlayableRockPaperScissors {
        RockPaperScissorsEnum play();
    }

## Решения и пояснения
В языке программирования Java загрузчик классов (Class Loader) является важной частью Java Virtual Machine (JVM) и отвечает за динамическую загрузку классов во время выполнения программы. Загрузка классов происходит по запросу, когда класс впервые используется в программе.

### Зачем нужен загрузчик классов:

- **Динамическая загрузка:** Загрузчик классов позволяет динамически загружать классы во время выполнения, что является ключевым компонентом концепции "поддержки изменений" и "горячей замены кода" в Java. Это обеспечивает гибкость и расширяемость приложений.

- **Изоляция классов:** Загрузчики классов обеспечивают изоляцию классов и пространств имен, что позволяет загружать различные версии одного и того же класса в разных загрузчиках. Это полезно в случаях, когда приложение использует библиотеки с разными версиями.

- **Безопасность и контроль доступа:** Загрузчики классов могут применять политики безопасности, определять, откуда можно загружать классы, и обеспечивать контроль доступа к ресурсам.

### Иерархия загрузчиков классов:

В JVM существует иерархия загрузчиков классов. Каждый загрузчик классов имеет свою зону ответственности. Основные типы загрузчиков:

- **Bootstrap Class Loader (Загрузчик бутстрэп-классов):** Этот загрузчик является частью самой JVM и загружает системные классы из директории jre/lib.

- **Extension Class Loader (Загрузчик расширений):** Загружает классы из директории jre/lib/ext.

- Application Class Loader (Загрузчик приложений): Также известен как System Class Loader, загружает классы из путей, указанных в переменной окружения CLASSPATH.

- **Пользовательские загрузчики:** Вы можете создавать свои собственные загрузчики классов, наследуясь от класса ClassLoader. Это полезно, например, при загрузке классов из удаленных источников или при реализации собственных механизмов динамической загрузки.

### Процесс загрузки классов:

- **Loading (Загрузка):** Загрузчик классов находит и загружает байт-код класса. Это может происходить из файла на диске, JAR-архива, удаленного источника и т.д.

- **Linking (Связывание):** В этом этапе класс связывается с другими классами, резолвятся ссылки на другие классы и интерфейсы.

- **Initialization (Инициализация):** Выполняются статические блоки кода, переменные и методы, подготавливая класс к использованию.

## Задача 1
В рамках задания необходимо было создать систему, позволяющую загружать плагины в игровую систему. Основная цель - обеспечить возможность разработчикам писать свои плагины, даже если имена классов могут совпадать.

**Реализация:**

1. **`PluginManager`**: Создан класс `PluginManager`, который принимает корневую директорию для плагинов. Метод `load` загружает плагин по заданным именам.

2. **`Plugin` Интерфейс**: Определен интерфейс `Plugin`, который должен быть реализован всеми плагинами. Он содержит метод `doUseful`, который представляет функциональность плагина.

3. **`PluginClassLoader`**: Реализован класс `PluginClassLoader`, который наследуется от `URLClassLoader`. Этот загрузчик ищет классы плагина по его имени и загружает их, игнорируя классы с аналогичными именами из основной системы.

4. **Обработка Имен Классов**: При загрузке плагина, если в основной системе существуют классы с аналогичными именами, они игнорируются, и загружаются только классы из плагина.

5. **Обработка Исключений**: Обработка различных исключений при загрузке классов и создании экземпляров плагина для обеспечения стабильной работы системы.

В результате была реализована система для динамической загрузки плагинов в игровую систему. Созданный `PluginManager` и `PluginClassLoader` позволяют гибко управлять процессом загрузки и обеспечивают возможность разработки плагинов, несмотря на возможное совпадение имен классов.

## Задача 2
В данном домашнем задании необходимо было создать `EncryptedClassLoader` - загрузчик классов, способный загружать зашифрованные классы из файлов и дешифровывать их для последующего использования в программе. Ключ шифрования, корневая директория для поиска классов и родительский загрузчик передаются при создании `EncryptedClassLoader`.

**Реализация:**

1. **Конструктор:** Создан конструктор класса, который принимает ключ шифрования, директорию для поиска классов и родительский загрузчик.

2. **Метод findClass:** Переопределен метод `findClass`, который считывает зашифрованный массив байт из файла, дешифрует его с использованием ключа, а затем преобразует его в класс с помощью метода `defineClass`.

3. **Чтение из файла:** Реализован метод `readBytesFromFile`, читающий все байты из файла.

4. **Дешифрование:** Реализован метод `decrypt`, который дешифрует зашифрованные байты с использованием ключа.

5. **Хеширование ключа:** Создан метод `hashKey`, который хеширует ключ с использованием алгоритма SHA-256.

В результате был реализован `EncryptedClassLoader`, способный загружать и дешифровывать зашифрованные классы. Решение включает в себя безопасное чтение байт из файла, дешифрование их с использованием заданного ключа и преобразование в класс.

## Задача 3
В данном домашнем задании требовалось написать игру "Камень-Ножницы-Бумага", в которой роли игроков выполняют плагины (файлы с расширением jar). Плагины должны загружаться, поочередно играть в раундах, и проигравшие плагины должны выгружаться, а на их место загружаться следующие плагины. Действия повторяются до определения победителя. Плагин-победитель остаётся в памяти.

**Реализация:**

1. **Интерфейс PlayableRockPaperScissors:** Создан интерфейс, который плагины должны реализовать. Интерфейс содержит метод `play()`, возвращающий случайное значение из перечисления `RockPaperScissorsEnum` (Камень, Ножницы, Бумага).

2. **Перечисление RockPaperScissorsEnum:** Создано перечисление, представляющее три возможных значения для игры - Камень, Ножницы, Бумага.

3. **Класс RockPaperScissorsPlayer:** Реализован класс, реализующий интерфейс `PlayableRockPaperScissors`. В методе `play()` выбирается случайное значение из перечисления.

4. **Класс MainRingApplication:** Основной класс приложения. Загружает плагины из заданной директории, создает очередь плагинов и запускает турнир до определения победителя.

5. **Методы playRound и whoWinRound:** Реализованы методы для игры одного раунда между двумя плагинами и определения победителя раунда.

6. **Методы playMatch и whoWinMatch:** Реализованы методы для игры матча (несколько раундов) между двумя плагинами и определения победителя матча.

7. **Метод getPlugins и getPluginFiles:** Реализованы методы для получения всех плагинов из заданной директории и всех файлов с расширением .jar в этой директории.

В результате была создана игра "Камень-Ножницы-Бумага" с использованием плагинов. Плагины загружаются, поочередно участвуют в матчах, проигравшие выгружаются, а победитель остается в памяти. Реализована инфраструктура для динамической загрузки и выгрузки плагинов.